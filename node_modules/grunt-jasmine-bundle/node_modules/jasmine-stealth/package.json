{
  "name": "jasmine-stealth",
  "version": "0.0.13",
  "description": "Makes Jasmine spies a bit more robust",
  "homepage": "https://github.com/searls/jasmine-stealth",
  "author": {
    "name": "Justin Searls"
  },
  "main": "main.js",
  "dependencies": {
    "coffee-script": "~ 1.6.3",
    "minijasminenode": "~0.2.4"
  },
  "devDependencies": {
    "lineman": ">=0.11.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/searls/jasmine-stealth.git"
  },
  "readme": "# jasmine-stealth\n\n[![Build Status](https://secure.travis-ci.org/searls/jasmine-stealth.png)](http://travis-ci.org/searls/jasmine-stealth)\n\n\njasmine-stealth is a [Jasmine](https://github.com/pivotal/jasmine) helper that adds a little sugar to Jasmine's spies.\n\n**[Download the latest version here](https://github.com/searls/jasmine-stealth/releases/0.0.12/1752/jasmine-stealth.js)**.\n\n# Conditional Stubbing\n\n## \"when\" + \"thenReturn\"\n\nOne annoyance with Jasmine spies is the default semantics of `Spy#andReturn` limits you to a single return value, regardless of which arguments a spy is invoked with. However, the arguments a spy is called with *usually matter* to the spec. None of your out-of-the-box options are great:\n\n1. You could instead use `Spy#andCallFake` to return conditionally. But this isn't very expressive, and may grow fatter if more conditions are added.\n\n2. You could write an additional `it` that uses `toHaveBeenCalledWith`, but then we're verifying the same call that we're stubbing, which requires the spec to be redundant in order to be complete.\n\n3. You could just leave the arguments unspecified and leave the spec as incomplete.\n\nEnter jasmine-stealth, which adds a `#when` method to Jasmine's spies. It lets you specify a conditional stubbing by chaining `thenReturn`. Example:\n\n``` javascript\ndescribe(\"multiple stubbings\", function() {\n  var someSpy;\n  beforeEach(function() {\n    someSpy = jasmine.createSpy();\n    someSpy.when(\"pirate\", { booty: [\"jewels\",jasmine.any(String)]}).thenReturn(\"argh!\");\n    someSpy.when(\"panda\",1).thenReturn(\"sad\");\n  });\n\n  it(\"stubs the first accurately\", function() {\n    expect(someSpy(\"pirate\",{ booty: [\"jewels\",\"coins\"]})).toBe(\"argh!\");\n  });\n\n  it(\"stubs the second too\", function() {\n    expect(someSpy(\"panda\",1)).toBe(\"sad\");\n  });\n\n  it(\"doesn't return anything when a stubbing isn't satisfied\",function(){\n    expect(someSpy(\"anything else at all\")).not.toBeDefined();\n  });\n});\n```\n\nIt's worth noting that Jasmine matchers will work with when-thenReturn (see the usage of `jasmine#any` above).\n\n### \"whenContext\"\n\nSometimes you want conditional stubbing, but based on the value of `this` as opposed to the arguments passed to a method. Specifying interactions with jQuery plugins is where I seem to need this most. For that case, you can use `whenContext` in place of `when`, like so:\n\n``` javascript\nspyOn($.fn,'show');\n\n$.fn.show.whenContext($('body')).thenReturn(\"a completely contrived example.\")\n```\n\n### thenCallFake\n\nYou can also use `thenCallFake` (just like jasmine's `andCallFake` on vanilla spies).\n\n``` javascript\nsomeSpy.when(\"correct\",\"params\").thenCallFake(function(){ window.globalsRock = true; });\n\nsomeSpy(\"correct\",\"params\");\n\nexpect(window.globalsRock).toBe(true);\n```\n\n# Spying on constructors\n\njasmine-stealth adds a facility to spy on a constructor. That way, when your subject code\nthat's under test instantiates a collaborator, you can access its methods as a collection of spies.\n\nSay we have a `view` that instantiates a `model`. Here's an example spec that uses `spyOnConstructor` to isolate the view from the model.\n\n``` coffee\n#source\nclass window.View\n  serialize: ->\n    model: new Model().toJSON()\nclass window.Model\n\n#specs\ndescribe \"View\", ->\n  describe \"#serialize\", ->\n    Given -> @modelSpies = spyOnConstructor(window, \"Model\", [\"toJSON\"])\n    Given -> @subject = new window.View()\n    Given -> @modelSpies.toJSON.andReturn(\"some json\")\n    When -> @result = @subject.serialize()\n    Then -> expect(@result).toEqual\n      model: \"some json\"\n```\n\n# Custom matchers\n\nThe problem:\nJasmine currently only comes with one matcher out-of-the-box, `jasmine.any()`. You can pass a type to it (a la `jasmine.any(Number)`) in any situation where\na variable is going to be evaluated with Jasmine's internal deep-equals function, such as with `expect().toEqual()` or `expect().toHaveBeenCalledWith()`.\n\nHere's an passing example that uses jasmine.any():\n\n``` javascript\nvar panda = {\n  name: \"Lulu\"\n}\n\nexpect(panda).toEqual({\n  name: jasmine.any(String)\n});\n```\n\njasmine-stealth adds a couple of my favorite custom matchers from other test double libraries: `jasmine.argThat()` and `jasmine.captor()`\n\n## argThat matcher\n\nWhat if we wanted to specify more than just the type of the argument, but we didn't want (or weren't able) to specify the argument's exact value? That's why jasmine-stealth includes a new matcher: `jasmine.argThat()`.\n\nSay that we wanted the panda's name was shorter than 5 characters? Well, now we can:\n\n``` javascript\nexpect(panda).toEqual({\n  name: jasmine.argThat(function(arg){ return arg.length < 5; })\n})\n```\n\nOf course, this looks a little nicer in terser CoffeeScript:\n\n``` coffee\nexpect(panda).toEqual\n  name: jasmine.argThat((arg) -> arg.length < 5)\n```\n\n`jasmine.argThat()` will also work in a spy's `toHaveBeenCalledWith` expectation, like so:\n\n``` coffee\nspy = jasmine.createSpy()\n\nspy(54)\n\nexpect(spy).toHaveBeenCalledWith jasmine.argThat (arg) -> arg < 100\nexpect(spy).not.toHaveBeenCalledWith jasmine.argThat (arg) -> arg > 60\n```\n\n## Argument Captors\n\nA different approach to the same problem as above is to use argument captors. It's just another style that\nmay read better in some specs than `jasmine.argThat()`.\n\nHere's a contrived example of the captor API:\n\n``` javascript\n\n//In our spec code's setup\nvar captor = jasmine.captor()\nvar save = jasmine.createSpy()\n\n//Meanwhile, in our production code\nsave({ name: \"foo\", phone: \"123\"});\n\n//Back in our spec\nexpect(save).toHaveBeenCalledWith(captor.capture())\nexpect(captor.value.name).toBe(\"foo\")\n\n```\n\nSo, when you want to capture an argument value, you first create a captor with `jasmine.captor()`, then in your expectation on the call to the spy, you call the captor's `capture()` function in place of the argument you want to capture. The captured value will be available on the captor's `value` property.\n\nArgument captors are useful in situations where your spec is especially concerned with the details of what gets passed to some method your code depends on. They're a very handy tool in the toolbox, but keep in mind that if you find yourself frequently relying on argument captors to specify your code, it may be a smell that your code is in the (bad) habit of breaking [command-query separation](http://en.wikipedia.org/wiki/Command-query_separation).\n\n### Summarizing matchers\n\nTo summarize, you now have several ways to get at the values that your code passes to your spec's spies:\n\n  1. You could interrogate the spy with Jasmine's built-in properties (a la `mySpy.calls[0].args[0] === \"foo\"`)\n  2. You could use `jamine.argThat()` and write a callback function that implies some expectation\n  3. You could use jasmine-stealth's `jasmine.captor()` to capture the value during your normal `toHaveBeenCalledWith` expectation and set up any number of expectations against it.\n\n\n# Other goodies jasmine-stealth adds\n\n## mostRecentCallThat\n\nSometimes it's helpful to look for a certain call based on some arbitrary criteria (usually the arguments it was passed with).\n\njasmine-stealth adds the method `mostRecentCallThat(truthTest,context)` to each spy, and it can be used to nab the call you want by passing in a truth test.\n\nSee this example:\n\n``` javascript\n\nspy = jasmine.createSpy();\nspy('foo',function(){});\nspy('bar',function(){});\nspy('baz',function(){});\n\nvar barCall = spy.mostRecentCallThat(function(call) {\n  return call.args[0] === 'bar';\n}); //returns the invocation passing 'bar'\n\nbarCall.args[1]() //invoke the function argument on that call (presumably to test its behavior)\n\n```\n\nYou can also pass mostRecentCallThat a context (a value for `this` if the truth test needs access to a `this` object.)\n\n## #createStubObj\n\nSometimes you want a fake object that stubs multiple functions. Jasmine provides `jasmine.createSpyObj`, which takes a name and an array of function names as parameters, but it doesn't make it any easier to set up stubbings for each of those passed functions.\n\nHere's an example:\n\n``` javascript\n\nvar person = jasmine.createStubObj('person',{\n  name: \"Steve\",\n  salary: 1.00,\n  stealAnIdea: function(){ throw \"I'm going to sue you!\"; }\n});\n\n```\n\nFollowing the above, `person.name()` is a normal jasmine spy configured to return steve (with `andReturn`). Likewise, invoking `person.salary()` will return `1.00`. You can also pass in functions as stubs, which will be passed to `andCallFake`; therefore, invoking `person.stealAnIdea()` will throw an exception.\n\n*Disclaimer: If you find yourself setting up many functions on a stub, beware: complex stubs are smell that there's excessive coupling between the code under test and the dependency being faked.*\n\n## Other stub aliases\n\nI can [often](http://searls.heroku.com/2011/06/03/whats-wrong-with-rubys-test-doubles/) [be](https://github.com/pivotal/jasmine/issues/88#issuecomment-2132975) [found](http://stackoverflow.com/questions/5208089/are-there-any-test-spy-libraries-available-for-objective-c) [complaining](https://github.com/searls/gimme) about the nomenclature of test doubles. One reason: when test double libraries conflate stubbing and verifying, developers not versed in Test Double Scienceâ„¢ get confused more frequently.\n\nI love spies (over mocks) for verification. But most of the time I don't need verification; I only want to stub behavior.\n\nSo in jasmine-stealth, I've added a couple aliases to Jasmine's spy creation to allow spec authors to discriminate their intent. They are:\n\n    jasmine.createStub(\"a stub for #myMethod\");\n\nAnd\n\n    stubFor(myObject,\"bestMethodEver\");\n\nBoth will create spies, but now the spec's intent will be a tad more clear. Especially when building a heavy-weight dependency in a `beforeEach` like this one:\n\n``` javascript\nvar subject,dependency;\nbeforeEach(function(){\n  dependency = {\n    query: jasmine.createStub(\"#query\"),\n    count: jasmine.createStub(\"#count\"),\n    save: jasmine.createSpy(\"#save\")\n  }\n  subject = Subject(dependency);\n});\n```\n\nThat might help the reader figure out your intent, but obviously you're free to take it or leave it.\n\n# Using with Node.js\n\nTo use this helper with Jasmine under Node.js, simply add it to your package.json with\n\n``` bash\n$ npm install jasmine-stealth --save-dev\n```\n\nAnd then from your spec (or in a spec helper), `require('jasmine-stealth')`. Be\nsure that it's loaded after jasmine itself is added to the `global` object, or else\nit will load `minijasminenode` which will, in turn, load jasmine\ninto `global` for you (which you may not be intending).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/searls/jasmine-stealth/issues"
  },
  "_id": "jasmine-stealth@0.0.13",
  "_from": "jasmine-stealth@~0.0.13"
}
