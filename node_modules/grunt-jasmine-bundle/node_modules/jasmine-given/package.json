{
  "name": "jasmine-given",
  "version": "2.4.0",
  "description": "Adds a Given-When-Then DSL to jasmine as an alternative style for specs",
  "homepage": "https://github.com/searls/jasmine-given",
  "author": {
    "name": "Justin Searls"
  },
  "main": "main.js",
  "dependencies": {
    "coffee-script": "~ 1.6.3",
    "minijasminenode": "~0.2.4"
  },
  "devDependencies": {
    "lineman": ">=0.11.0"
  },
  "keywords": [
    "jasmine",
    "bdd"
  ],
  "bugs": {
    "url": "https://github.com/searls/jasmine-given/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/searls/jasmine-given.git"
  },
  "licenses": [
    {
      "name": "Apache License 2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0"
    }
  ],
  "readme": "[![Build Status](https://secure.travis-ci.org/searls/jasmine-given.png)](http://travis-ci.org/searls/jasmine-given)\n\n## 2.x series\n\nWe just released a version 2.0.0, thanks to the contributions of [@ronen](https://github.com/ronen), to bring jasmine-given closer to parity with rspec-given. In particular, jasmine-given will now:\n\n* ensure that `Given` statements [will *always* execute before](#execution-order-givens-then-whens-then-thens) any `When` statements. This is counter-intuitive at first, but can really help you DRY up specs that require variable setup.\n* [allow users to use `And` in place of multiple `Then` statements](#supporting-idempotent-then-statements); when using `And` following a `Then`, the set-up will only be executed for the first `Then`, which could be a significant speed-up depending on the test while looking cleaner than chaining `Then` statements with parentheses.\n\nKeep in mind that the former will be a **breaking change** for many test suites that currently use jasmine-given, so be sure to allot yourself some time to address any test failures that occur because a `Given` was incidentally placed after a `When` in a way that doesn't agree with the new execution order.\n\n# jasmine-given\n\njasmine-given is a [Jasmine](https://github.com/pivotal/jasmine) helper that encourages leaner, meaner specs using `Given`, `When`, and `Then`. It is a shameless tribute to Jim Weirich's terrific [rspec-given](https://github.com/jimweirich/rspec-given) gem.\n\n**[Download the latest version here](https://github.com/searls/jasmine-given/releases/2.1.0/1131/jasmine-given.js)**.\n\nThe basic idea behind the \"*-given\" meme is a humble acknowledgement of given-when-then as the best English language analogue we have to arrange-act-assert. With rspec and jasmine, we often approximate \"given-when-then\" with \"let-beforeEach-it\" (noting that jasmine lacks `let`).\n\nThe big idea is \"why approximate given-when-then, when we could actually just use them?\"\n\nThe small idea is \"if we couldn't write English along with our `it` blocks then we'd be encouraged to write cleaner, clearer matchers to articulate our expectations.\"\n\nThe subtle idea is that all \"given\"s should be evaluated before the \"when\"s.  This can DRY up your specs: you don't need to repeat a series of \"when\"s in order to test the final result with different initial \"given\"s.\n\nAll ideas are pretty cool. Thanks, Jim!\n\n## Example (CoffeeScript)\n\nOh, and jasmine-given looks *much* nicer in CoffeeScript, so I'll show that example first:\n\n``` coffeescript\ndescribe \"assigning stuff to this\", ->\n  Given -> @number = 24\n  Given -> @number++\n  When -> @number *= 2\n  Then -> @number == 50\n  # or\n  Then -> expect(@number).toBe(50)\n\ndescribe \"assigning stuff to variables\", ->\n  subject=null\n  Given -> subject = []\n  When -> subject.push('foo')\n  Then -> subject.length == 1\n  # or\n  Then -> expect(subject.length).toBe(1)\n```\n\nAs you might infer from the above, `Then` will trigger a spec failure when the function passed to it returns `false`. As shown above, traditional expectations can still be used, but using simple booleans can make for significantly easier-to-read expectations when you're asserting something as obvious as equality.\n\n## Example (JavaScript)\n\nOf course, jasmine-given also works fine in JavaScript; but as you can see, it's exceptionally clunky in comparison:\n\n``` javascript\ndescribe(\"assigning stuff to this\", function() {\n  Given(function() { this.number = 24; });\n  Given(function() { this.number++; });\n  When(function() { this.number *= 2; });\n  Then(function() { return this.number === 50; });\n  // or\n  Then(function() { expect(this.number).toBe(50) });\n});\n\ndescribe(\"assigning stuff to variables\", function() {\n  var subject;\n  Given(function() { subject = []; });\n  When(function() { subject.push('foo'); });\n  Then(function() { return subject.length === 1; });\n  // or\n  Then(function() { expect(subject.length).toBe(1); });\n});\n```\n\n## Execution order: Givens then Whens then Thens\n\nThe execution order for executing a `Then` is to execute all preceding `Given` blocks\nfrom the outside in, and next all the preceding `When` blocks from the outside in, and\nthen the `Then`.  This means that a later `Given` can affect an earlier `When`!\nWhile this may seem odd at first glance, it can DRY up your specs, especially if\nyou are testing a series of `When` steps whose final outcome depends on an\ninitial condition.  For example:\n\n```\n    Given -> user\n    When -> login user\n\n    describe \"clicking create\", ->\n\n        When -> createButton.click()\n        Then -> expect(ajax).toHaveBeenCalled()\n\n        describe \"creation succeeds\", ->\n            When -> ajax.success()\n            Then -> object_is_shown()\n\n            describe \"reports success message\", ->\n                Then -> feedback_message.hasContents \"created\"\n\n            describe \"novice gets congratulations message\", ->\n                Given -> user.isNovice = true\n                Then -> feedback_message.hasContents \"congratulations!\"\n\n            describe \"expert gets no feedback\", ->\n                Given -> user.isExpert = true\n                Then -> feedback_message.isEmpty()\n```\nFor the final three `Then`s, the execution order is:\n\n```\n       Given -> user\n       When -> login user\n       When -> createButton.click()\n       When -> ajax.success()\n       Then -> feedback_message.hasContents \"created\"\n\n       Given -> user\n       Given -> user.isNovice = true\n       When -> login user\n       When -> createButton.click()\n       When -> ajax.success()\n       Then -> feedback_message.hasContents \"congratulations!\"\n\n       Given -> user\n       Given -> user.isExpert = true\n       When -> login user\n       When -> createButton.click()\n       When -> ajax.success()\n       Then -> feedback_message.isEmpty()\n```\nWithout this `Given`/`When` execution order, the only straightforward way to get the above\nbehavior would be to duplicate then `When`s for each user case.\n\n## Supporting Idempotent \"Then\" statements\n\nJim mentioned to me that `Then` blocks ought to be idempotent (that is, since they're assertions they should not have any affect on the state of the subject being specified). As a result, one improvement he made to rspec-given 2.x was the `And` method, which—by following a `Then`—would be like invoked **n** `Then` expectations without executing each `Then`'s depended-on `Given` and `When` blocks **n** times.\n\nTake this example from jasmine-given's spec:\n\n``` coffeescript\ndescribe \"eliminating redundant test execution\", ->\n  context \"a traditional spec with numerous Then statements\", ->\n    timesGivenWasInvoked = timesWhenWasInvoked = 0\n    Given -> timesGivenWasInvoked++\n    When -> timesWhenWasInvoked++\n    Then -> timesGivenWasInvoked == 1\n    Then -> timesWhenWasInvoked == 2\n    Then -> timesGivenWasInvoked == 3\n    Then -> timesWhenWasInvoked == 4\n```\nBecause there are four `Then` statements, the `Given` and `When` are each executed four times. That's because it would be unreasonable for Jasmine to expect each `it` function  to be idempotent.\n\nHowever, spec authors can leverage idempotence safely when writing in a given-when-then format. You opt-in with jasmine-given by using `And` blocks, as shown below:\n\n``` coffeescript\n  context \"chaining Then statements\", ->\n    timesGivenWasInvoked = timesWhenWasInvoked = 0\n    Given -> timesGivenWasInvoked++\n    When -> timesWhenWasInvoked++\n\n    Then -> timesGivenWasInvoked == 1\n    And -> timesWhenWasInvoked == 1\n    And -> timesGivenWasInvoked == 1\n    And -> timesWhenWasInvoked == 1\n\n    Then -> timesWhenWasInvoked == 2\n```\n\nIn this example, `Given` and `When` are only invoked one time each for the first `Then`, because jasmine-given rolled all of those `Then` & `And` statements up into a single `it` in Jasmine.  Note that the label of the `it` is taken from the `Then` only.\n\nLeveraging this feature is likely to have the effect of speeding up your specs, especially if your specs are otherwise slow (integration specs or DOM-heavy).\n\nThe above spec can also be expressed in JavaScript:\n\n``` javascript\n\ndescribe(\"eliminating redundant test execution\", function() {\n  context(\"a traditional spec with numerous Then statements\", function() {\n    var timesGivenWasInvoked = 0,\n        timesWhenWasInvoked = 0;\n    Given(function() { timesGivenWasInvoked++; });\n    When(function() { timesWhenWasInvoked++; });\n    Then(function() { return timesGivenWasInvoked == 1; });\n    Then(function() { return timesWhenWasInvoked == 2; });\n    Then(function() { return timesGivenWasInvoked == 3; });\n    Then(function() { return timesWhenWasInvoked == 4; });\n  });\n\n  context(\"chaining Then statements\", function() {\n    var timesGivenWasInvoked = 0,\n        timesWhenWasInvoked = 0;\n    Given(function() { timesGivenWasInvoked++; });\n    When(function() { timesWhenWasInvoked++; });\n    Then(function() { return timesGivenWasInvoked == 1; })\n    And(function() { return timesWhenWasInvoked == 1; })\n    And(function() { return timesGivenWasInvoked == 1; })\n    And(function() { return timesWhenWasInvoked == 1; })\n  });\n});\n\n```\n## Invariants\n\nRspec-given also introduced the notion of \"Invariants\".  An `Invariant` lets you specify a condition which should always be true within the current scope.  For example:\n\n```\n\n    Given -> @stack = new MyStack @initialContents\n\n    Invariant -> @stack.empty? == (@stack.depth == 0)\n\n    describe \"With some initial contents\", ->\n        Given -> @initialContents = [\"a\", \"b\", \"c\"]\n        Then -> @stack.depth == 3\n\n        describe \"Pop one\", ->\n           When -> @result = @stack.pop\n           Then -> @stack.depth == 2\n\n        describe \"Clear all\", ->\n           When -> @stack.clear()\n           Then -> @stack.depth == 0\n\n    describe \"With no contents\", ->\n      Then -> @stack.depth == 2\n\n    …etc…\n\n```\n\nThe `Invariant` will be checked before each `Then` block. Note that invariants do not appear as their own tests; if an invariant fails it will be reported as a failure within the `Then` block.  Effectively, an `Invariant` defines an implicit `And` which gets prepended to each `Then` within the current scope.  Thus the above example is a DRY version of:\n\n```\n\n    Given -> @stack = new MyStack @initialContents\n\n    describe \"With some initial contents\", ->\n        Given -> @initialContents = [\"a\", \"b\", \"c\"]\n        Then -> @stack.depth == 3\n        And -> @stack.empty? == false\n\n        describe \"Pop one\", ->\n           When -> @result = @stack.pop\n           Then -> @stack.depth == 2\n         And -> @stack.empty? == false\n\n        describe \"Clear all\", ->\n           When -> @stack.clear()\n           Then -> @stack.depth == 0\n           And -> @stack.empty? == true\n\n    describe \"With no contents\", ->\n      Then -> @stack.depth == 0\n      And -> @stack.empty? == true\n\n    …etc…\n\n```\n\nexcept that the `Invariant` is tested before each `Then` rather than after.\n\n# \"it\"-style test labels\n\nJasmine-given labels your underlying `it` blocks with the source expression itself, encouraging writing cleaner, clearer matchers -- and more DRY than saying the same thing twice, once in code and once in English.  But there are times when we're using third-party libraries or matchers that just don't read cleanly as English, even when they're expressing a simple concept.\n\nOr, perhaps you are using a collection of `Then` and `And` statements to express a single specification.  So, when needed, you *may* use a label for your `Then` statements:\n\n        Then \"makes AJAX POST request to create item\", -> expect(@ajax_spy).toHaveBeenCalled()\n        And -> @ajax_spy.mostRecentCall.args[0].type = 'POST'\n        And -> @ajax_spy.mostRecentCall.args[0].url == \"/items\"\n        And -> @ajax_spy.mostRecentCall.args[0].data.item.user_id == userID\n        And -> @ajax_spy.mostRecentCall.args[0].data.item.name == itemName\n\n# Using with Node.js\n\nTo use this helper with Jasmine under Node.js, simply add it to your package.json with\n\n``` bash\n$ npm install jasmine-given --save-dev\n```\n\nAnd then from your spec (or in a spec helper), `require('jasmine-given')`. Be\nsure that it's loaded after jasmine itself is added to the `global` object, or else\nit will load `minijasminenode` which will, in turn, load jasmine\ninto `global` for you (which you may not be intending).\n",
  "readmeFilename": "README.md",
  "_id": "jasmine-given@2.4.0",
  "_from": "jasmine-given@~2.4.0"
}
